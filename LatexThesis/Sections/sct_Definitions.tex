\section{Definitions of the Constants, Costs, Variables and Functions}
This section is more intended for mathematicians and computer scientists too. Those who don't wish to read the mathematical parts should still broadly understand the variables of harmonic intervals, melodic intervals and motions (\textbf{H}, \textbf{M} and \textbf{P} in section \ref{sec:variables}). Subsections \ref{sec:constants} and \ref{sec:variables} describes the various names used in the mathematical parts and in the Lisp code of the solver (immediately to their right, e.g. \textbf{n} \space \texttt{*total-cp-len}). These subsections explain also how those constants and variables work. Unless otherwise stated, all domains of constants and variables belong to the domain of integers $\mathbb{N}$.

% CONSTANTS
\subsection{Constants}\label{sec:constants}
Constants are only constant with respect to the Gecode solver, so they are deduced before a solution is sought by the latter.

\paragraph{Cons $_{(all,\ p,\ imp)}$} \texttt{ALL\_CONS}, \texttt{P\_CONS}, \texttt{IMP\_CONS}

Set representing all consonances, perfect consonances and imperfect consonances respectively. By default, the notation $Cons \equiv Cons_{all}$.

\begin{equation}
    \begin{gathered}
        Cons_{p} := \{0, 7\}\\
        Cons_{imp} := \{3, 4, 8, 9\}\\
        Cons_{all} := Cons_{p} \cup Cons_{imp} \equiv \{0, 3, 4, 7, 8, 9\}
    \end{gathered}
\end{equation}

\paragraph{species} \texttt{species}

Chosen species of counterpoint. $species \in \{1, 2, 3, 4, 5\}$.

\paragraph{m} \texttt{*cf-len}

Number of measures which is equivalent to the number of notes in the \cfdot $m \in [3, 17]$. $3$ because the solver needs al least 3 measures to work properly. $17$ is arbitrary and comes from $4\times 4 + 1$, i.e. a commun number of measure $\times$ a number not too large for the computation $+$ one final measure.

\paragraph{n} \texttt{*total-cp-len}

Number of notes in the counterpoint depending on the chosen species. $n \in [1, b(m-1)+1]$ because the last measure has necessarily a whole note.

\paragraph{s$_{m}$}

Maximum number of notes contained in the counterpoint, all species combined, i.e. if the counterpoint contained only quarter notes, with the exception of the last note being a whole note.

\begin{equation}
    s_{m} = m + 3\times (m-1) \text{ and }s_{m-1} = (m-1) + 3\times (m-2)
\end{equation}

Used as the size for an array containing one list of size $m$ (or $m-1$) the notes in thesis and three lists of size $m-1$ (or $m-2$) the other beats. The difference with $n$ is that $s$ does not depend on $b$.

\paragraph{Cf} \texttt{*cf}

List of size $m$ representing the MIDI notes of the \cfdot

\begin{equation}
    \begin{gathered}
        \forall j \in [0, m)\\
        Cf[j] \in [0, 127]
    \end{gathered}
\end{equation}

\paragraph{M$_{cf}$} \texttt{*cf-brut-m-intervals}

List of size $m-1$ representing the melodic intervals between the consecutive notes of the \cfdot

\begin{equation}
    \begin{gathered}
        \forj\\
        M_{cf}[j]=Cf[j+1]-Cf[j]\\
        \text{where } M_{cf} \in [-127, 127]
    \end{gathered}
\end{equation}
% N.B.: any melodic interval should ideally be in the range $[-12, 12]$.

\paragraph{lb} \texttt{RANGE\_LB}

Lower bound of the range of the notes of the counterpoint. $lb \in [0, ub)$.

\paragraph{ub} \texttt{RANGE\_UB}

Upper bound of the range of the notes of the counterpoint. $ub \in (lb, 127]$.

\paragraph{$\R$} \texttt{*cp-range}

Range of the notes of the counterpoint. $\R := [lb, ub]$.

\paragraph{borrow} \df{major}\footnote{\df{value} means the default value in the tool.}

Determines the "borrowing scale", i.e. the additional notes that the counterpoint can have in relation to the tonic of the piece. More details will be given on what are the borrowed notes in section \ref{sec:generalenglish}.

\begin{equation}
    \begin{gathered}
        borrow \in \{none, major, minor\}
    \end{gathered}
\end{equation}

\paragraph{$\N_{(all,\ key,\ brw)}^{(\R)}$} \texttt{*extended-cp-domain}, \texttt{*scale}, \texttt{*borrowed-scale}.

Set of values available for the notes of the counterpoint. $\N_{key}$ represents the notes of the key provided by the user's score. $\N_{brw}$ represents the additional borrowed notes that the counterpoint can have in relation to the tonic of the piece. $\N_{all}$ represents the union of the two previous sets. If $borrow = none$ then $\N_{brw} = \emptyset$ and $\N_{all} = \N_{key}$. $\N_{(all,\ key,\ brw)}^{\R}$ represents the set of notes bounded to the range, i.e. the intersection of $\N_{(all,\ key,\ brw)}$ and $\R$. By default, $\N$ refers to $\N_{all}$ not bounded to the range.

\begin{equation}
    \begin{gathered}
        \N_{key} := buildScale(key, scale)\\
        \N_{brw} := \begin{cases}
            \emptyset & \text{if } borrow = none\\
            buildScale(Cf[0]\ mod\ 12, "borrowed") & \text{if } borrow = major\\
            buildScale([Cf[0]+3]\ mod\ 12, "borrowed") & \text{if } borrow = minor
        \end{cases}\\
        \N_{all} := \N_{key} \cup \N_{brw}\\
        \N_{(all,\ key,\ brw)}^{\R} := \N_{(all,\ key,\ brw)} \cap \R\\
    \end{gathered}
\end{equation}

Where $buildScale(key, scale)$ (see function \ref{eq:buildScale}) is a function that returns the set of notes in the $key$ based on the $scale$ used. Also more details on the borrowed notes will be given in section \ref{sec:generalenglish}.

\subsection{Costs}
The costs are constants chosen by the user that have default values supposed to represent Fux's preferences.

\paragraph{pref and cost} \texttt{*params*}

A preference can have 7 levels of intensity ranging from "no cost" to "forbidden". For any cost $cost$ and any preference $pref$, it can be defined that:

\begin{equation}
    \begin{gathered}
        cost = \begin{cases}
            0 & \text{if } pref = \text{no cost}\\
            1 & \text{if } pref = \text{low cost}\\
            2 & \text{if } pref = \text{medium cost}\\
            4 & \text{if } pref = \text{high cost}\\
            8 & \text{if } pref = \text{last resort}\\
            2m & \text{if } pref = \text{cost prop. to length}\\
            64m & \text{if } pref = \text{forbidden}
        \end{cases}
    \end{gathered}
\end{equation}

$64m$ is a ridiculously huge value that will never be reached by all the other costs combined even if they were all high.

\paragraph{Cond$_{costs}$ and cost$_{Cond}$} All costs work the same way: a list of boolean variables, called $Cond$ for the explanation, determines whether it is true that a certain cost should be established for this specific condition in certain locations. The list of assigned costs for this condition is noted $Cond_{costs}$. The elements of $Cond_{costs}$ are thus equivalent to any cost $cost$ depending on the preference $pref$ chosen for the condition $Cond$. The different costs for the different types of conditions each have their own identifier noted $cost_{Cond}$. It is this value that changes depending on the user's preference. To sum up:

% \begin{equation}
%     \begin{gathered}
%         \forall c \in Cond_{costs}, \forall cond \in Cond\\
%         c = \begin{cases}
%             cost_{Cond} & \text{if } cond \text{ is true}\\
%             0 & \text{otherwise}
%         \end{cases}\\
%         \text{where } cost_{Cond} \in dom(cost)
%     \end{gathered}
% \end{equation}

\begin{equation}
    \begin{gathered}
        \forall \rho \in Positions(Cond)\\
        Cond_{costs}[\rho] = \begin{cases}
            cost_{Cond} & \text{if } Cond[\rho] \text{ is true}\\
            0 & \text{otherwise}
        \end{cases}\\
        \text{where } Positions(Cond) \text{ is the set of positions where the condition } Cond \text{ applies}\\
        \text{ and where } cost_{Cond} \in dom(cost)
    \end{gathered}
\end{equation}

\paragraph{$\C$ and $\tau$} \texttt{*cost-factors}, \texttt{*total-cost}.

The heuristic of the solver leads to find a solution while minimizing the total cost. The latter is represented by $\tau$ while $\C$ is a set of integers representing all the sums of the different lists of costs. $\tau$ is thus the sum of all the elements of $\C$. If $Costs$ is the set of all the different $Cond_{costs}$ lists then:

\begin{equation}
    \begin{gathered}
        \C = \bigcup _{\forall \chi \in Costs} \ \sum _{\forall c \in \chi} c\\
        \tau := \sum _{\forall \sigma \in \C} \sigma\\
        \min \tau
    \end{gathered}
\end{equation}

By definition, for any forbidden $pref$ to be indeed \emph{forbidden}, the following constraint must be added:

\begin{equation}
    \begin{gathered}
        \sum _{\forall \sigma \in \C} \sigma < 64m
    \end{gathered}
\end{equation}

\input{Sections/sct_Variables.tex}

% FUNCTIONS
\subsection{Fonctions}
Functions are a way to improve the readability of some more complex mathematical notations. The majority remain relatively simple.
\paragraph{nextm(x)} Returns the number of measure(s) to add in 4/4 time signature depending on the number of beat $x$.
\begin{equation}
    nextm(x) = \begin{cases}
        1 + nextm(x-4)& \text{if } x \geq 4\\
        0 & \text{otherwise}
    \end{cases}
    \label{eq:nextm}
\end{equation}

\paragraph{buildScale(key, scale)} Returns the set of notes in the $key$ based on the $scale$ used. $key$ is a value between 0 and 11 such that $0 \equiv C$ and $11 \equiv B$.

\begin{equation}
    \begin{gathered}
        \forall x \in [-11, 127], \forall \delta := key+x \in [0, 127]\\
        buildScale(key, scale) = \begin{cases}
            \bigcup _{\delta\ mod\ 12 \in key + \{0, 2, 4, 5, 7, 9, 11\}} \delta & \text{if } scale = \text{major}\\
            \bigcup _{\delta\ mod\ 12 \in key + \{0, 2, 3, 5, 7, 8, 10\}} \delta & \text{if } scale = \text{minor}\\
            \bigcup _{\delta\ mod\ 12 \in key + \{0, 5, 9, 11\}} \delta & \text{if } scale = \text{borrowed}
        \end{cases}\\
        \text{where } key \in [0, 11], scale \in \{"major", "minor", "borrowed"\}
    \end{gathered}
    \label{eq:buildScale}
\end{equation}
N.B.: $buildScale(key, "minor") \equiv buildScale([key+3]\ mod\ 12, "major")$.

\paragraph{Membership function $e \in E$} State that $e$ belongs to $E$. Technically, that's a fact but, \emph{in the context of this paper}, this function can be used as a boolean function to evaluate an implication. It is then considered that this function returns a boolean value that is true if $e$ is in the set $E$.

\begin{equation}
    \begin{gathered}
        E := \{e_0, \dots, e_n\}\\
        e \in E = \begin{cases}
            \top & \text{if } (e = e_0) \lor \dots \lor (e = e_n)\\
            \bot & \text{otherwise}
        \end{cases}
    \end{gathered}
\end{equation}

As a result, when an expression uses only $\in$, it implies that this expression is true, i.e the element must belong to the set: $e \in E \equiv (e \in E \iff \top)$. This refers directly to the way Gecode allows this constraint. It may not follow convention, but it will be simpler and still used with common sense.

In the code, the constraints are often expressed separately for each element. For example, for a constraint $cst$ which is applied if $e \in \{x, y, z\}$, it would state:

\begin{equation*}
    \begin{gathered}
        (e = x) \implies cst;\quad (e = y) \implies cst;\quad (e = z) \implies cst
    \end{gathered}
\end{equation*}