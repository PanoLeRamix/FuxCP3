% Software architecture
% - Macro-architecture: Diagram of OM + GiL + Gecode
% - Micro-architecture:
% -> Files (utils, constraints, 1st species, 2nd species, ...)
% -> Dispatcher of species (diagram)
% -> Array constraints diagram (move to introduction of variables?)
% - Issues (move to further improvements?)
% -> 1) Dealing with Lisp and GiL (hard to write): this is where it becomes a real problem (diagram of OM + GiL + Gecode)
% -> 2) Dealing with bad methodology: Agile does not allow a good architecture when the language is unknown
% -> 3) Lack of OOP (polymorphism) for the species: it would be better to have an interface that define *total-cp, *m-all-intervals, etc. and then have the 1st species as first class and have the 2nd class that inherits from the first one.
% Branching (further improvements)
% - branching with minimum cost (not optimal)
% - difference between performance, add function to heuristic ?
\chapter{Future Improvements}\label{ch:future}
Given the vast field of computer-aided composition, several points could not be covered in this paper. This thesis is part of a large-scale project and several developers will continue this work which is gradually taking shape. This chapter will therefore cover the few points that need to be improved, as well as a few suggestions to ensure that the project progresses as smoothly as possible.

\section{Software Architecture}
A brief explanation of the project's architecture is available in appendix \ref{ch:software_arch} to better understand how the software works overall. The Lisp code in this thesis does not have a good architecture for scalability. Indeed, the lack of Lisp skills and an iterative approach with short deadlines has led to an architecture containing "code smells"\footnote{A code smell is a characteristic of a bad code that indicates a certain type of problem\parencite{CodeSmells}. In this case, the code contains some bloaters and change preventers\parencite{Guru}.}. For example, object-oriented programming is a good paradigm for developing this project, but its use was not really emphasized.

Currently, constraints are added to a species via a long function that dispatches the constraints, rather than via class inheritance. Ideally, object-oriented inheritance should be used to represent the different variable arrays and species. All variable arrays ($H$, $M$, $P$, etc.) have something in common, whether in terms of their size relative to the \cfcomma or in terms of the way certain rules are applied. A relatively abstract class should represent this type of array to enable these commonalities to be brought together.

The same applies to species that share common rules and should have been represented in a class system of their own. It would be logical for species to be children of the first species. Unfortunately, the scope of this work does not allow for a complete overhaul of the architecture. Moreover, in the near future, the entire code may have to be redone in C++ for reasons of performance, features, maintainability, and so on. Also, GiL has reached its limits, both in terms of ease of programming and in terms of possibilities. The Lisp language is not designed for writing mathematics, since each operation requires a different function call. Code readability can become complicated because these calls are all represented by parentheses. At the same time, it is not possible with GiL to combine basic mathematical operations to form a larger one. One has to break down each complex operation into simple intermediate basic operations a bit like writing assembly, which is undesirable for larger projects. Not to mention that branch-and-bound, heuristics, and multithreading seem complicated to implement in GiL.

Gecode is already a parser implemented in C++, so we strongly advise against using and maintaining GiL in future projects. Constraints should all be written in C++ using the features and facilities that have been implemented in Gecode.

\section{Solver Performances}
So far, few optimizations have been implemented to reduce the search time of the solver. Performance was not a particularly important point until the fifth species which requires more resources. Most of the time, the solutions are found quickly but in some cases, the solutions can take several minutes, or even never be found in a reasonable time. Indeed, some extreme cases lead to inefficient branching which only finds solutions in infinite time. This is due to several points.

First, the branching is not very dynamic and therefore does not adapt much to the parameters chosen by the user. It is just different with respect to the species. Also, a minimal cost to the solution is provided to prevent the solver from looking for solutions with too low costs that cannot exist. But this remains rudimentary and is not sufficient to find solutions with certain parameters.

Second, for minimization problems, Gecode uses a specific class where the space cost is kept in a variable to be able to minimize it efficiently. Gecode has optimized its algorithm for this kind of problem and does not use simple naive branching. GiL, a priori, does not allow the use of this feature, which undoubtedly considerably slows down the search for a solution. Also, the solver's solutions don't have to be the best but just "good enough".

Third, the current branching is very naive. For example, for the third and fifth species, a branching is done on the cost of the melodic intervals to start finding solutions with no cost on this level. By default, this means that the solver searches for stepwise solutions which, indeed, makes finding solutions much easier. But in fact, it would be better to have a function for this part of the heuristic to first find solutions with mainly joint intervals but also some disjoint intervals. This third point is related to both the performance and the quality of the solutions.

\section{Solution Quality}
During the evaluation, it was shown that several notions on the global architecture of the melody were missing from the formalization. Whether through constraints, heuristic functions, or branch-and-bound, these notions must be represented to find more human solutions. The human ear likes to be able to predict notes but also needs to be surprised from time to time so as not to get bored. This is exactly the problem the solver is struggling to handle. Everything is a question of balance which should be represented by the direction the solver takes when looking for solutions.

As explained above, this can be introduced by a more complex heuristic, capable of looking for solutions including certain skips at places that seem coherent. It can also be introduced by a heuristic including certain patterns in the solution to try to either repeat them or avoid them. It is also possible to find other formalizations of counterpoint giving "macro rules" capable of governing the progression of counterpoint as a whole. Some of these rules can be detected via more general works or via counterpoint statistical analyzes using certain algorithms or certain machine learning models. Several possibilities are offered to the next developers of this project.

Lately, an interesting feature would be that composers can impose a rhythm and certain notes so that the user experience is more complete. This would make it possible to create variations to the melodies and to use the tool as a real component in the creation of a complete work where counterpoint would only be part of it.
