\section{Constraint Programming Prerequisites}
This thesis is more focused on mathematical formalization than on the extensive use of constraint programming. Indeed, as will be explained later, optimization is not a point that was particularly highlighted during this work. The limits of Gecode were not reached within the framework of this work. There was thus no need to investigate in that specific direction. Despite this, it is still important to understand what constraint programming is. 

\subsection{Constraint Programming Concept}
Constraint programming is an approach to solve complex combinatorial problems by specifying them as logical relations, called constraints\parencite{CPbook}. This kind of problem is called \textit{constraint satisfaction problem} or CSP. It is solved by using a combination of inference and search. CP is a powerful paradigm in the field of computer science that addresses complex decision-making and optimization problems.

Problems are represented as a set of variables, each with a domain of possible values, and constraints that define the allowable combinations of values for these variables. Constraints capture logical relationships between variables, reflecting the problem's requirements.

The solver part has to find a solution that satisfies all the given constraints by determining the values for the variables that do not violate previously posted constraints. In practice, CP engines employ constraint propagation techniques to enforce the constraints and reduce the search space by propagating the effects of variable assignments.

\subsection{Branching}
Branching refers to the selection of variables and their values during the exploration of the solution space. It involves selecting a variable and dividing its domain into smaller subsets or branches, each representing a possible assignment.

When solving a CSP with Gecode, there are two fundamental search strategies employed: depth-first search and branch-and-bound. These strategies are guided by variable selection heuristics and value selection heuristics. Without going into details, depth-first search assigns values to variables regarding the heuristics and then backtracks when constraints cannot be satisfied. The branch-and-bound strategy extends depth-first search by incorporating an additional mechanism to post a new constraint specified in advance\footnote{With the current version of GiL, it has never been possible to make branch-and-bound work from Lisp. Several attempts were tested but all failed.}.

The choice of variable for branching is guided by variable selection heuristics, which determine the order in which variables are considered during the search process. These heuristics aim to select the most promising variable at each step, leading to faster convergence. Common variable selection heuristics include selecting the variable with the fewest remaining values in its domain (minimum domain size) or selecting the variable involved in the most constraints (maximum degree). Value selection heuristics determine the order in which values are assigned to variables. These heuristics aim to prioritize values that are more likely to lead to a successful solution.

\subsection{Advantages}
To summarize the benefits that lead to the use of CP, it can be said that it mainly stands out for its expressiveness, transparency, flexibility, and efficiency. CP allows problem solvers to express problems in a natural manner, enabling direct communication of knowledge and requirements. It provides transparency in the problem-solving process, making search algorithms and strategies explicit and understandable. CP supports flexible problem modeling, allowing the incorporation of additional constraints, objectives, and problem-specific knowledge. It can efficiently explores the solution space using constraint propagation and search techniques, reducing the search space and quickly discarding infeasible solutions. These advantages make CP valuable for addressing a wide range of real-world decision-making and optimization problems.